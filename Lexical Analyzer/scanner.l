/* 
 * File: scanner.l
 * Part 1: Lexical Analyzer for a Swift Subset
 * This file can be compiled and run independently.
 */

/* C declarations section. This code is copied directly into the generated C file. */
%{
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

/*
 * To make this lexer standalone (without the Yacc parser), we'll define the token types ourselves.
 * In Part 2, these definitions will come from a header file generated by Yacc (parser.tab.h).
 * We use an 'enum' for this, which assigns a unique integer to each token name.
 */
enum {
    // Keywords
    LET = 258, // Start after ASCII values to avoid conflicts
    VAR, FUNC, RETURN, IF, ELSE, FOR, IN, WHILE, REPEAT, SWITCH, CASE, DEFAULT, STRUCT,
    
    // Type Names
    TYPE_INT, TYPE_DOUBLE, TYPE_BOOL, TYPE_CHAR, TYPE_STRING, TYPE_VOID,
    
    // Literals & Identifier
    IDENTIFIER, INT_LITERAL, DOUBLE_LITERAL, STRING_LITERAL, BOOL_LITERAL,
    
    // Operators
    EQ, NEQ, LT, GT, LTE, GTE, AND, OR, ARROW
};

/*
 * yylval is a special global variable that the lexer uses to pass the *value* of a token 
 * back to the parser. We define it as a union because a token's value can have different types.
 */
typedef union {
    int ival;
    double dval;
    int bval;
    char *sval;
} YYSTYPE;

YYSTYPE yylval;

%}

/* Flex options */
%option noyywrap
%option yylineno

/* Regular Expression Definitions */
DIGIT           [0-9]
LETTER          [a-zA-Z_]
IDENTIFIER_CHAR [a-zA-Z0-9_]

%%

[ \t\n]+	{ /* ignore whitespace */ }
"//".* 		{ /* ignore comments */ }

"let"		{ return LET; }
"var"		{ return VAR; }
"func"		{ return FUNC; }
"return"	{ return RETURN; }
"if"		{ return IF; }
"else"		{ return ELSE; }
"for"		{ return FOR; }
"in"		{ return IN; }
"while"		{ return WHILE; }
"repeat"	{ return REPEAT; }
"switch"	{ return SWITCH; }
"case"		{ return CASE; }
"default"	{ return DEFAULT; }
"struct"	{ return STRUCT; }
"Int"		{ return TYPE_INT; }
"Double"	{ return TYPE_DOUBLE; }
"Bool"		{ return TYPE_BOOL; }
"Character"	{ return TYPE_CHAR; }
"String"	{ return TYPE_STRING; }
"Void"		{ return TYPE_VOID; }

{DIGIT}+			{ yylval.ival = atoi(yytext); return INT_LITERAL; }
{DIGIT}+\.{DIGIT}+		{ yylval.dval = atof(yytext); return DOUBLE_LITERAL; }
\"[^"\n]*\"			{ yylval.sval = strdup(yytext); return STRING_LITERAL; }
"true"				{ yylval.bval = 1; return BOOL_LITERAL; }
"false"				{ yylval.bval = 0; return BOOL_LITERAL; }

{LETTER}{IDENTIFIER_CHAR}*	{ yylval.sval = strdup(yytext); return IDENTIFIER; }

"=="		{ return EQ; }
"!="		{ return NEQ; }
"<="		{ return LTE; }
">="		{ return GTE; }
"&&"		{ return AND; }
"||"		{ return OR; }
"->"		{ return ARROW; }

.		{ return yytext[0]; }

%%

int main(int argc, char **argv) {
    if (argc > 1) {
        FILE *file = fopen(argv[1], "r");
        if (!file) {
            perror(argv[1]);
            return 1;
        }
        yyin = file;
    }

    int token;
    while ((token = yylex())) {
        printf("Line %d, Token: ", yylineno);
        switch (token) {
            case LET: printf("LET"); break;
            case VAR: printf("VAR"); break;
            case FUNC: printf("FUNC"); break;
            case RETURN: printf("RETURN"); break;
            case IF: printf("IF"); break;
            case ELSE: printf("ELSE"); break;
            case FOR: printf("FOR"); break;
            case IN: printf("IN"); break;
            case WHILE: printf("WHILE"); break;
            case REPEAT: printf("REPEAT"); break;
            case SWITCH: printf("SWITCH"); break;
            case CASE: printf("CASE"); break;
            case DEFAULT: printf("DEFAULT"); break;
            case STRUCT: printf("STRUCT"); break;
            case TYPE_INT: printf("TYPE_INT"); break;
            case TYPE_DOUBLE: printf("TYPE_DOUBLE"); break;
            case TYPE_BOOL: printf("TYPE_BOOL"); break;
            case TYPE_CHAR: printf("TYPE_CHAR"); break;
            case TYPE_STRING: printf("TYPE_STRING"); break;
            case TYPE_VOID: printf("TYPE_VOID"); break;
            case IDENTIFIER: printf("IDENTIFIER, Value: %s", yylval.sval); break;
            case INT_LITERAL: printf("INT_LITERAL, Value: %d", yylval.ival); break;
            case DOUBLE_LITERAL: printf("DOUBLE_LITERAL, Value: %f", yylval.dval); break;
            case STRING_LITERAL: printf("STRING_LITERAL, Value: %s", yylval.sval); break;
            case BOOL_LITERAL: printf("BOOL_LITERAL, Value: %s", yylval.bval ? "true" : "false"); break;
            case EQ: printf("EQ"); break;
            case NEQ: printf("NEQ"); break;
            case LTE: printf("LTE"); break;
            case GTE: printf("GTE"); break;
            case AND: printf("AND"); break;
            case OR: printf("OR"); break;
            case ARROW: printf("ARROW"); break;
            default:
                printf("'%c'", token);
                break;
        }
        printf("\n");
    }
    return 0;
}